## Template To Target Document

### 需求阐释

在一些场景下，需要为用户生成一份测试报告，报告内容由数据库中存储的测试结果+固定样式进行填充，报告格式为常见文档格式，如pdf doc docx等。整个过程可以分为两部分：

1，使用一种模板语言定义一份该模板语言所支持格式的文档模板，动态填充数据后输出该格式文档；

2，如果用户需求的格式不被支持，需要进行二次转换

### 技术选型思路

#### 方案1

1，在一开始并未完全理解用户对于文档格式的需求，且并不了解输入格式其实可以有很多种，错误的将输入格式限制为html，所以此时的思路就变成了模板->html->pdf/doc

2，在不考虑模板填充数据这个步骤时，此时的技术难点是html->pdf，在经过一定的查阅后得知itext7是比较主流的pdf库，支持用代码的方式编写pdf，html直接转化为pdf等

3，当html为静态原生文档时，一切正常且能满足需求；但是在实际情况中，html中需要使用第三方js库如echart动态运行js生成相应的图表等插入html中，也就是需要一个js的运行环境（浏览器或者node）并获取最终的html文档内容，使用该内容进行转换

4，itex提供了一种evaluate js的方案，需要借助selenium的驱动连接库+对应平台浏览器的驱动执行程序，通过driver.get(url)来生成完整的html文档

5，在test时，当js本身并不复杂，如create一个p element时，运行结果正常。但是当js运行时间很长时，官方提供了driver wait的解决方案，思路即等待到文档流中某个条件达成后再进行输出，个人感觉还不错的一个判断条件为：

```java
driver->driver.excuteScript("return document.readystade").equals("complete")
```

其中driver获取文档流，以及对于流中元素的操作有很多方法和注意事项，并没有做深入了解。

官方文档：https://www.selenium.dev/zh-cn/documentation/webdriver/

6，itext7在介绍使用webdriver时，在访问文档内容这一块在某些条件下有些问题;webdriver的官方文档推荐方式为get或navigate.to(url),其中url为对应的html文档的协议+路径;而itext7的demo中先获取html文档的文档内容，并与data:text/html头部进行拼接，将带头的完整文档流交给driver。在这种方式下，当文档流的内容很长时，比如我使用了echart.js库，整个文档就有上万行，driver在解析该url时会出现错误。无法定位其原因，我的猜想是因为selnium其实就是借助浏览器的环境，此时的链接过长，可能超出了浏览器对于url的长度限制，导致其根本无法正常的解析该文档流。

7，此时驱动的配置以及wait条件都正确，理论输出已经符合标准。但是在topdf时发现，echart表格显式为空白，查询之后发现是因为前端的echart显式格式为canvas，而canvas是html的元素，且是运行时的绘制机制，对于pdf这种静态文档是无法实现的

8，了解到echart提供了ssr的解决方案，图表可输出对应的SVG，或者使用Canvas通过dataurl生成图片的文件流。

​	8.1，SVG本是最优选择，因为矢量图较为精简，且对于缩放有很好的适配性，其在浏览器中显式也很完美，但是在转换为pdf之后svg	的显式会出现错位现象。

​	~~itext本身是支持创建svg并插入文档的，个人认为是因为不同平台在渲染svg时的差异性所导致。因为html中的svg仍然是~~

​	具体的错位为所有的文字，居中属性全部失效。该问题定位了非常久，在大致浏览了svg语法后，将生成的svg标签单独保存为svg文	件，在浏览器中浏览也完全正常。当我通过itext官网的转换工具将该svg转换为pdf后，其中pdf的样式也是错误的；又陆续查找了一些其他的svg to pdf 工具，也只有部分工具可以正确转换。其实pdf本身是不支持插入svg图片的，这些库都是通过解析svg标签，通过不同的方式在pdf中进行渲染，比如文字就是插入pdf文字，图形有的使用了形状，而有的则将所有图形合并生成一个背景或者图片。总之需要明白pdf是不支持svg的，至少我没有找到插入svg的选项！那么就可以解释通了：itext在解析svg的过程中，忽视了text-anchor的属性，导致其在pdf中排版文字时发生了位置错误。虽然定位到了问题，但是很遗憾并不能很直接的解决该问题，因为itext parse+convert的过程算是一个“黑盒”，目前没有发现能对其进行扩展的入口，也就是说SvgConverter是其内部定义好的，我们无法替换。

​	可以认为这就是免费版itex的bug，它不能完美的处理svg并将其转换为pdf。如果想解决该问题我有两个思路：

​	1，替换itext，寻找对svg支持更好的库。但是在搜寻一圈后，发现较完善且仍在维护的库大多数都是收费的如ironPdf这些商用解决方案;免费的如open pdf，pdfbox，flysaucer等虽然可扩展性较强，但是维护不是很好，如果对文档流比较熟悉可以考虑进行二次开发，定制能符合自己需求的库，这需要较多的前置知识和hack time；随后又发现了一个wkhtmltopdf库，很意外其对svg的支持相当好，甚至默认的字体都能支持中文。不过该库并不是一个java库而是一个c库，可以通过exe外部调用来处理，并且其提供了c源码，应该也可以通过jni的方式去调用。

​	2，既然不支持textanchor，那么就通过绝对定位将文字放在正确的位置。通过JS获取SVG的dom节点，并通过text长度和字号大小动态的将文字进行偏移，可以朝这个思路再搜索一下

9，由于itext在输出为pdf时对于文档中的文字需要指定字体，默认的字体无法支持中文，中文无法显式。需要下载支持中文的ttf文件，并且创建fontprovider后再传递给properties，最后转换时使用该properties就能正常显式中文

该方式并不优雅。因为selenium的设计目的是为复杂web提供自动化测试，本地模拟浏览器的环境开销会非常大。当需要并发运行js生成html时这显然会有巨大的开销

或许ssr需要结合node服务器提供相应的js运行环境

总结来说不推荐该方案，不论是生成html的性能损耗，以及最终html to pdf的对齐问题都有些棘手，需要重新考虑方向。

##### update

text-anchor的对齐问题最终通过JS遍历text节点，并计算label宽度进行偏移达到人工的居中

不过该方式尚存在一些问题，比如不同的模板，图表可能都需要手动引入并配置，其抽象程度还不够。并且遍历text节点，字符串的解析也是比较耗时的，性能上也不够优秀，不太确定其对性能造成的多余损耗。

且JS中通过字符的charCode判断单个字符占位宽度是稍微有些麻烦的，因为必须考虑到BMP字符集，无论是正则的方式，还是通过遍历charcode进行判断都要兼顾每种类型的字符。

排除上述问题这个方案确实是实现了我的需求，只不过逐渐认识到，对于这种需求JS运行环境的SSR方案，放在JAVA服务器中是一件相当别扭的方法，更合理的方式是在client与业务server中间，再架设一个node的服务器（如express等），ssr+模板全部通过nodejs的生态去解决；由于前后端分离，很多时候并不需要这个中间层，此时再通过nginx配合使用。nginx的优势在于负载均衡+静态资源处理+性能，

nginx反向代理到node.js有什么优势

#### blob url





